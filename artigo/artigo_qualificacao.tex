\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}	% Inclusão de gráficos


\usepackage{mathtools}
\usepackage[portuguese, ruled, linesnumbered]{algorithm2e}
\usepackage{float}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	tabsize=3
}
     
\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tabela}
     
\sloppy

\title{Algoritimo genético para resoler o problema do caixeiro viajante com o problemas de mochila para cálculo de rotas ótimas para robôs}

\author{Killdary A. Santana\inst{1}}


\address{Departamento de Engengharia Elétrica e da Computação \\ Universidade Federal do Ceará
	(UFC) -- Campus Sobral\\
	Caixa Postal 62010-560 -- Sobral -- CE -- Brazil
	\email{killdary.aguiar@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
	Route planning is becoming a daily task for activities that require the help of robots, such as robotic manipulators on assembly lines and transport robots in industries.
	The great challenge of these robots is to run a better route within their energy limitations. This paper presents the study and development of an application for the planning of beasted routes in the Traveling Salasmen Problem (TSP) combined with the Knapsack Problem (KP) using genetic algorithm (GA). 	
\end{abstract}

\begin{resumo} 
	O planejamento de rotas está se tornando a cada dia uma tarefa corriqueira para 
	atividades que necessitem do auxílio de robôs, como manipuladores robóticos 
	em linhas de montagem e robôs de transporte em indústrias.
	O grande desafio desses robôs é executar uma melhor rota dentro das 
	suas limitações energéticas. Este artigo apresenta o estudo e desenvolvimento 
	de uma aplicação para o planejamento de rotas baseados no Problema do Caixeiro Viajante(PVC) 
	combinado ao Problema da Mochila(PM) por meio de algorítmo genético(AG).
\end{resumo}


\section{Introdução}

Com o avanço da tecnologia os robôs se tornaram mais eficazes na execução de diversas tarefas, podendo executar funções que antes eram consideradas impossíveis para uma máquina, deixando de ser um componente caro e acessível apenas para grandes indústrias e passando a atuar nas mais diversas aplicações que antes eram executadas por humanos, impulsionando assim o desenvolvimento de robôs autônomos.

A finalidade da pesquisa de robôs móveis com autonomia é construir máquinas para realizar tarefas com precisão e capazes de tomar decisões adequadas frente a uma situação inesperada. 

Muitos projetos podem ser observados com as mais diversas finalidades, como exploração de ambientes não estruturados como florestas\cite{article}, exploração de planetas como marte\cite{Nasa:17}, futebol de robôs\cite{ROBOCUP:17}, carros autônomos\cite{Google:19},  aplicações agrícolas\cite{TABILE2011}, entre muitos outros. 

Um dos maiores desafios encontrados em robôs móveis se dá no planejamento de sua trajetória e tem recebido grande atenção por parte dos pesquisadores, tanto na indústria como no meio acadêmico, pois seu desenvolvimento está diretamente relacionado com a maior autonomia dos robôs. A complexidade do problema de planejamento do movimento tem motivado o desenvolvimento dos mais diversos algoritmos. Tal complexidade advém da necessidade de integrar a navegação do robô com o sensoriamento, a eficiência e o planejamento de rotas, como também poupar recurso importantes e preservação de suas partes mecânicas. A habilidade de planejamento de rotas deve estar presente na programação interna dos robôs para que os mesmos possam decidir quando será necessário alterar sua rota de modo a minimizar o impacto em compração ao planejamento inicial.


O problema de roteirização de robôs pode ser modelado através do Problema do Caixeiro Viajante(PCV), porém o PVC não é suficiente para modelar a roteirização de rotas dentro de limitações do robô, como limitação energética ou de peso máximo a ser transportado, sendo assim o mesmo deve ser combinado ao Problema da Mochila(PM) para uma modelagem mais próxima a realidade. Este trabalho tem como objetivo desenvolver um algorítmo genético que forneça a melhor rota para um robô maximizando os ganhos que o mesmo pode realizar dentro de uma limitação energética.

Na próxima seção será descrito o PCV e sua variação síncrona, o PM e a combinação do PCV e PM. Na seção 3 será abordado a fundamentação teórica do problema e da solução a ser implementada. A seção 4 abordará os métodos de implementação e suas metodologias. Na seção 5  será exposto os resultados obtidos oriundos da seção 4, enquanto a conclusão será apresentada na seção 6, e por fim na seção 7 os trabalhos futuros.

\section{Problema do Caixeiro Viajante com o Problema da Mochila} \label{sec:PCVPM}
Para uma melhor representação do problema de roteirização de robôs com restrições será combinado o PCV e o PM. A seguir será apresentado o PCV e sua variação síncrona, usada como base do algorítmo, o PM com sua variação do Problema da Mochila Binária, para adicionar a visitação de uma cidade apenas uma vez, e por fim a combinação dos dois problemas na formulação matemática final.
\subsection{Problema do Caixeiro Viajante} \label{sec:PCV}

O Problema do Caixeiro Viajante (PCV) tem sido muito utilizado no experimento
de diversos métodos de otimização por ser, principalmente, um problema de fácil
descrição e compreensão, mas de grande dificuldade de solução, uma vez que é
NP-difícil(Non-Deterministic Polynomial time). O PCV determina que um vendedor tem N
cidades no qual o mesmo deveria visitar todas as cidades, sem repetir nenhuma, e
voltar para a cidade de partida de modo que o custo da viagem seja mínimo \cite{Singh2013StudyOV}. O
cálculo de rotas mínimas em robôs se assemelha ao PCV, sendo o robô o vendedor, as
cidades os pontos objetivos que o robô deve visitar e as arestas a distância que o robô percorrerá. O PCV é um problema de otimização combinatória, no qual o número de soluções possíveis é representado na equação \ref{fat}.

\begin{equation}\label{fat}
R(n)=(n-1)!
\end{equation}
Onde:
\begin{itemize}
	\item $n$: é o numero de cidades a serem visitadas;
\end{itemize}

\subsubsection{Formulação Matemática Para o PCV}

Seja o grafo $G(N, A)$ onde $N$ representa o conjunto $(|N|=n)$ e $A$ o conjunto de arestas. Seja, uma matriz simétrica com custos ou distâncias mínimas entre os nós da rede considerando ainda que $c_{ij} = +\infty \forall i \in N$. A matriz $X[x_{ij}]$ é composta pelas variáveis de decisão do problema

\begin{equation}
x_{ij} =
\begin{cases} 
1 &\text{, se: o arco } a_{ij} \in \text{rota}\\
0 &\text{, se: o arco } a_{ij} \notin \text{rota}
\end{cases}
\end{equation}

Desta forma, a formulação de Programação Linear Inteira para o problema\cite{doi:10.1287/opre.28.3.694} pode ser escrita como:

\begin{equation}\label{eq:1}
\sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}
Sujeito a:
\begin{equation}\label{eq:2}
\sum_{i=1}^{n}x_{ij} \qquad j=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:3}
\sum_{j=1}^{n}x_{ij} \qquad i=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:4}
X = x_{ij}  \in S
\end{equation}
\begin{equation}\label{eq:5}
x_{ij}=0  \qquad\text{ou} \qquad x_{ij}=1
\end{equation}

Os dois primeiros grupos de restrições (\ref{eq:2}) e (\ref{eq:3}) garantem que exatamente um arco $(i, j)$ tem origem cada nó $i$ da rota e exatamente um arco$(i, j)$ é direcionado para um nó $j$ da rota. A penúltima restrição (\ref{eq:4}) contém um subconjunto $S$ que pode ser qualquer conjunto de restrições que impeça a formação de sub-rotas. Estas restrições são chamadas restrições de quebra de sub-rotas e podem ser, entre outras:

\newcommand{\pctext}[2]{\text{\parbox{#1}{\centering #2}}}
\begin{equation}
S= \biggl\{(x_{ij}) \geq 1 \text{,para todo conjunto próprio não vazio $Q$ de $N$}\biggr\} 
\end{equation}

\begin{equation}
S= \biggl\{(x_{ij}) \leq |R| -1\text{, para todo subconjunto não vazio $R$ de \{ 2,..., n \}} \biggr\} 
\end{equation}


\begin{equation}
S = \biggl\{(x_{ij}):y_i - y_j + nx_{ij} \leq (n-1) \; \text{, para $2\leq i \neq j \leq n$ para alguns números reais $y_i$} \biggr\} 
\end{equation}

O PVC pode ser classificado em simétrico, onde os custos de um caixeiro ir da cidade A para a cidade B e vice-versa são os mesmos, ou assimétrico, onde os custos de movimentação de uma cidade A para uma cidade B podem ser diferentes de ir da cidade B para a cidade A. Para este trabalho será focado no problema \textbf{simétrico}.


\subsubsection{Problema do Caixeiro Viajante Simétrico} \label{sec:PCVS}

O PCVS possui a direção da arestas é irrelevante já que $c_{ij} = c_{ji}$. Uma vez que a direção não tem importância, é possível considerar que o grafo possui apenas um arco, sem direção, entre todos os pares de nós. Deste modo, $x_{j} \in 0,1$ é a variável de decisão onde $j$ percorre todos os arcos $A$ do grafo e $c_{j}$ é o custo de percorrer cada nó. Para encontrar um circuito no grafo, deve selecionar um subconjunto de arcos, no qual todos os nós estejam contidos. Assim, o problema pode ser formulado como:
\begin{equation}\label{fat2}
R(n)=\frac{(n-1)!}{2}
\end{equation}
de modo que o número de resposta é a metade da formulação (\ref{fat}). De modo semelhante ao assimétrico, os sub-circuitos devem ser eliminados. O problema pode então ser formulado como \cite{Tiago:19}:

\begin{equation}\label{eq:12}
min \frac{1}{2}\sum_{j=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}

\begin{equation}\label{eq:13}
 s.t.\sum_{k \in J(j)}^{}x_{k} = 2  \;  \;  \text{,para todo $j=1, ...,m$}
\end{equation}

\begin{equation}\label{eq:14}
\sum_{j \in E(S)}^{}x_{j} \leq |S| - 1  \;  \;  \text{,para todo $S\subset 1, ...,m$}
\end{equation}

\begin{equation}\label{eq:15}
x_j = 0 \text{ ou } x_j = 1  \;  \;  \text{,para todo $j \varepsilon  E$}
\end{equation}
onde $J(j)$ é o conjunto de todos os arcos, não direcionados, ligados ao nó $j$ e $E(S)$ é o subconjunto de todos os arcos que ligam as cidades em qualquer conjunto S não vazio que contenha todas as cidades\cite{Wikipedia:19}.

\subsection{Problema da Mochila (PM)} \label{sec:PM}
O PM é um problema de programação linear inteira, classificado como
NP-hard. O PM consiste de uma mochila com capacidade limitada, dentro dessa mochila deve ser colocado uma lista de itens, cada um com seu peso e valor, de modo que seja agrupado um conjunto de itens na bolsa que sua soma de peso não ultrapassem a capacidade da mochila e a soma dos valores seja a maior  possível\cite{Martello:1990:KPA:98124}. O cálculo da rota de um robô se assemelha ao PM, sendo o robô a mochila, a capacidade da mochila as restrições impostas ao robô, como peso máximo ou energia disponível, e os itens a serem colocados na mochilas são os pontos as serem visitados. 

O PM possui diversas variações, porém um robô que tem sua rota com base no PCV só deverá passar por um ponto uma única vez, sendo assim a o PM binário é a representação dp PM que mais aderente ao problema.

 
\subsubsection{PM binário e sua Formulação Matemática}
A variação PM binária consiste de um conjunto de itens $N$, que é formado por uma lista de $n$ itens $j$ com valor $p_{j}$ e peso $w_{j}$, cada item é de um tipo único, e o valor da capacidade da mochila sendo $C$. O objetivo é selecionar um subset de $N$ no qual a soma dos pesos não exceda $C$ e o valor seja o maior possível\cite{book:946517}. A lista de itens é composta por um vetor $Y[y_{j}]$, no qual

\begin{equation}\label{eq:16}
y_{i} =
\begin{cases} 
1 &\text{, se: o item } y_{i} \in \text{rota}\\
0 &\text{, se: o item } y_{i} \notin \text{rota}
\end{cases}
\end{equation}

Desta forma, a formulação matemática para o problema\cite{book:946517}\cite{Martello:1990:KPA:98124} pode ser descrita como:
r eliminados. O problema pode então ser formulado como \cite{Tiago:19}:

\begin{equation}\label{eq:17}
max \sum_{i=1}^{n}\sum_{i=1}^{n}p_{i}y_{i}
\end{equation}

\begin{equation}\label{eq:18}
s.t.\sum_{i=1}^{n}w_{i}y_{i} \leq  C
\end{equation}


\begin{equation}\label{eq:19}
y_i \in \left \{  0,1 \right \} \qquad i=1,...,m.
\end{equation}


A restrição (\ref{eq:18}) garante que a capacidade da mochila não será ultrapassada. A restrição (\ref{eq:19}) só assume valor $1$ ou $0$. A equação (\ref{eq:17}) garante o maior valor possível na mochila.

\subsection{Problema do Caxeiro Viajante Combinado ao Problema da Mocila (PCVPM)}\label{PCVPM}

Nesta seção, o objetivo deste artigo, a saber, o Problema do Caixeiro Viajante com Problema de Mochila (PCVPM).
Pode-se dizer que esse problema é a junção do PCV Simétrico com o PM binário, de modo que, para 
formulá-lo, foi decidido que devem ser mantidas as principais características de cada um
dos dois problemas componentes:
\begin{enumerate}
	\item Cidades visitadas geram prêmios.
	\item É necessário atender uma quantidade de cidades que proporcione a soma do custo entre cidades não ultrapasse o custo máximo estabelecido.
\end{enumerate}

Obviamente, a primeira caracterísitca é relativa ao PM, enquanto a segunda é uma combinação entre PCV e PM, no qual o peso do item a ser posto na mochila foi substituído pelo
custo de visitação entre as cidades. Observe que, dessa forma, nem todos as cidades precisam ser
visitadas.  O problema consiste em minimizar a soma dos custos de viagem, no qual sua rota é formada
por clientes suficientes para percorrer uma distância menor ou igual a distância preestabelecida,
maximizando os prêmios coletados a cada cliente visitado, de modo que as cidades inclusas na rota sejam visitadas uma única vez.

Mais precisamente, consideremos um grafo $G(N, A)$, onde $N$ representa o conjunto $(|N|=n)$ e $A$ o conjunto de arestas. Seja, uma matriz simétrica com custos ou distâncias mínimas entre os nós da rede considerando ainda que $c_{ij} = +\infty \forall i \in N$. As cidades $x_{i}$ que compõe o conjunto $N$ possuem um prêmio $p_i$. O custo máximo percorrido seja $C$ .A matriz $X[x_{ij}]$ é composta pelas variáveis de decisão do problema:

\begin{equation}
x_{ij} =
	\begin{cases} 
		1 &\text{, se: o arco } x_{ij} \in \text{rota}\\
		0 &\text{, se: o arco } x_{ij} \notin \text{rota}
	\end{cases}
\end{equation}



\begin{equation}
x_{i} =
	\begin{cases} 
		1 &\text{, se: a cidade } x_{i} \in \text{rota}\\
		0 &\text{, se: a cidade } x_{i} \notin \text{rota}
	\end{cases}
\end{equation}

Desta forma, a formulação de Programação Linear Inteira para o problema pode ser escrita como:


\begin{equation}\label{eq:obj_PCVPM}
max. f(x) = \alpha_P\sum_{i=0}^{n}p_{i}x_{i} - \beta_D \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}

sujeito as restrições:
	
	\begin{equation}\label{eq:PCVPM_rest1}
	\sum_{j=2}^{n}x_{1j} = 1 
	\end{equation}
	
	\begin{equation}\label{eq:PCVPM_rest2}
	\sum_{k=1}^{n-1}x_{in} = 1 
	\end{equation}
	
	\begin{equation}\label{eq:PCVPM_rest3}
	\sum_{i=1}^{n-1}x_{ni} = 0 
	\end{equation}

sobre a quantidade de visitações:


\begin{equation}\label{eq:PCVPM_vis1}
\sum_{i=1}^{n}x_{ij} \qquad j=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:PCVPM_vis2}
\sum_{j=1}^{n}x_{ij} \qquad i=1,2,\dots,n
\end{equation}

sobre a distância máxima a ser percorrida:

\begin{equation}\label{eq:PCVPM_Max_dist}
 \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij} \leq C_T
\end{equation}

sobre a aliminação de subrotas:

\begin{equation}\label{eq:PCVPM_sub1}
 1 \leq u_i \leq n \qquad\forall i \in T
\end{equation}


\begin{equation}\label{eq:PCVPM_sub2}
i_i - u_j + 1 \leq (1 + -x_{ij})n \qquad  2\leq i \neq j \leq n
\end{equation}


onde $n$ é o tamanho do conjunto de cidades a serem visitadas, $T$ é conjuntos de cidades que comõe uma rota viável, $c_{ij}$ é o custode movimentação entre uma cidade e outra, $p_i$ é o prêmio da $i$-ésima cidade, $\alpha_P$ e $\beta_D$ são os pesos na fução objetivo relacionados a maximização da premiação e minimização do custo

Neste problema as equações (\ref{eq:PCVPM_rest1}) e (\ref{eq:PCVPM_rest2}) são restrições sobre o ponto inicial e final que devem ser inclusos na rota, a restição (\ref{eq:PCVPM_rest3}) impõe que nenhum ponto apos chegar ao ponto final seja visitado, (\ref{eq:PCVPM_vis1}) e (\ref{eq:PCVPM_vis2}) restringe que cada ponto seja visitado apenas uma única vez, a equação (\ref{eq:PCVPM_Max_dist}) limita a distância máxoma percorrida a $C_{T}$, subrotas são impedidas de ser geradas pelas equações (\ref{eq:PCVPM_sub1}) e (\ref{eq:PCVPM_sub2}).

O resultaddesta otimização será um conjunto de vertices ordenados a serem visitados pelo agente.

\section{Algoritmo Genético}
Os Algoritmos Genéticos (AGs) são técnicas de otimização inspirados no
princípio da sobrevivência e reprodução dos indivíduos mais aptos, proposto por
Charles Darwin\cite{book:54924}\cite{book:1176457}.

O Algoritmo Genético é baseado em um conjunto de soluções candidatas que representam uma solução para o problema de otimização que se deseja resolver. Uma solução é um candidato em potencial para otimizar o problema. A forma de representação desempenha um papel importante, uma vez que determina a escolha dos operadores genéticos.

As representações geralmente são listas de valores e por muitas vezes são mais baseadas em conjuntos de
símbolos. Caso o conjunto de símbolos sejam contínuos, eles serão chamados de vetores, caso eles consistem em bits, eles
serão chamadas de strings de bits. Em caso de problemas combinatórios, as soluções geralmente consistem em
símbolos que aparecem em uma lista. A representação pode ser aplicado ao planejamento de rotas como um percurso realizado pelo caixeiro viajante. Os operadores genéticos produzem novas soluções a partir da representação escolhida e permite a aproximação da solução. A codificação da solução, no qual pode ser aplicado o processo evolutivo, é chamada de genótipo ou cromossomo.

O algoritmo \ref{algoritmo1} mostra o pseudocódigo do AG básico. No início, um conjunto de soluções, chamado de população, é inicializada. Esta inicialização é utilizada para gerar aleatoriamente o conjunto de soluções\cite{book:1613056}. 


\begin{algorithm}\label{algoritmo1}
	iniciar população;
	\Repeat{}{
		\Repeat{}{
			cruzamento\;
			mutação\;
			avaliação\;
			seleção\;
		}população completa\;
		atualização
		teste de Parada
	}finalização
	\caption{Algorítimo Genético}
\end{algorithm}

O principal ciclo geracional do Algoritmo Genético gera uma nova prole de soluções candidatas, através do cruzamento e  da mutação, até a população estar completa.

Para a metodologia de de eleção foi optado peloa forma de \textit{ranking}. Quanto ao cruzamento foi utilizado 3 métodos: \textit{one point}, \textit{two points} e \textit{sinusoidal}\cite{article:Hussain}. Já para as mutações foram realizados 4 tipos:  \textit{Swap}, \textit{Scramble}, \textit{Worst gene with random gene mutation} e \textit{Worst gene with nearest neighbor mutation }\cite{article:Hassanat}.

\section{Resultados}

	Nesta seção serão apresentados os resultados da simulação do cálculo de rotas para um agente para os seguintes cenários:
	
	\begin{itemize}
		\item Cenário 1 - Rota para 20 pontos, sem restrições de custo;
		\item Cenário 2 - Rota para 20 pontos, com limitação de custo;
		\item Cenário 3 - Rota para 30 pontos, sem restrições de custo;
		\item Cenário 4 - Rota para 30 pontos, com limitação de custo;
	\end{itemize}

	Para cada cenário foi gerado um conjuntos de pontos a serem visitados, e para cada ponto foi atribuído uma recompensa. Para o cálculo de custos entre os pontos foi utilizado o cálculo da distância euclidiana.
	
	A seguir serão mostrados os resultados das simulações para cada um dos 8 cenários apresentados.
	
	\subsection{Cenário 1 - Rota para 20 pontos, sem restrições de custo}	
	O cenário 1 relacionado com a simulação do cálculo de rota onde o agente não possui restrições de custo, e pode percorrer todas as cidades livremente. 
	para o cenário 1 foi utilizado os seguintes pontos.
	\begin{figure}[ht]
		\centering
		\includegraphics[width=.3\textwidth]{pontos_2.png}
		\caption{20 pontos}
		\label{fig:Pontos1}
	\end{figure}
	
	A pós a execução do algorítmo a seguinte rota foi encontrada:
	
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=.3\textwidth]{rota_2.png}
		\caption{Rota 1}
		\label{fig:rota1}
	\end{figure}
	
	Juntamente com a distância mínima de 37,38 metros e a pontuação máxima de 125 pontos.
	
	\subsection{Cenário 2 - Rota para 20 pontos, com limitação de custo}	
	O cenário 2 é estabelecido em cima dos mesmos pontos estabelecidos no cenário 1(\ref{fig:Pontos1}), porém agora ao algorítmo foi imposta a restrição de percorrer no máximo 23 metros, sendo assim o seguinte resultado foi encontrado.
	
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=.3\textwidth]{rota_c_2.png}
		\caption{Rota 1}
		\label{fig:rota}
	\end{figure}
	
	Para o Cenário 2 o algorítmo foi executado um total de 30 vezes, sendo a 22,23 metros com uma pontuação de 58,0 pontos. 
	
	
	\subsection{Cenário 3 - Rota para 30 pontos, sem restrições de custo}	
	
	O cenário 3  relacionado com a simulação do cálculo de rota onde o agente não possui restrições de custo, e pode percorrer todas as cidades livremente. 
	Para o cenário 3 foi utilizado um conjunto de 30 pontos a serem visitados, como mostrado a seguir.
	\begin{figure}[ht]
		\centering
		\includegraphics[width=.4\textwidth]{pontos_3.png}
		\caption{30 pontos}
		\label{fig:Pontos3}
	\end{figure}
	
	Após a execução do algorítmo a seguinte rota foi encontrada:	
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=.3\textwidth]{rota_3.png}
		\caption{Rota 3}
		\label{fig:rota3}
	\end{figure}
	
	Juntamente com a distância mínima de 71,24 metros e a pontuação máxima de 149 pontos.
	
	\subsection{Cenário 4 - Rota para 30 pontos, com limitação de custo}	
	O cenário 4 foi estabelecido em cima dos mesmos pontos utilizados no cenário 3(\ref{fig:Pontos1}), porém agora ao algorítmo foi imposta a restrição de percorrer no máximo 35 metros, sendo assim o seguinte resultado foi encontrado.


	\begin{figure}[h]
		\centering
		\includegraphics[width=.3\textwidth]{rota_c_3.png}
		\caption{Rota 3}
		\label{fig:rota2}
	\end{figure}

	Para o Cenário 4 o algorítmo foi executado um total de 30 vezes, sendo a 33,66 metros com uma pontuação de 71,0 pontos. 

\section{Conclusão}

O algoritmo proposto neste trabalho, visa principalmente a otimização e a busca por
soluções satisfatórias, em ambientes que possuam ou não alguma restrição no agente. os testes executados mostraram resultados promissores para a busca de rotas otimizadas com restrições, porém ainda inconcluisivas já que para uma real avaliação será necessário um número maior de variabilidade de pontos e premiações para estudar melhor o comportamento do algorítmo.

Como proposta futura, tem-se a intenção de adaptar o algorítmo a utilizar rotas geradas pelo TSPLIB, e alterar possíveis formas de mutação e crossover, e o claculo de rotas com restrições para múltiplos agents.
%



%\subsubsection{ BeagleBone Black (BBB)}
%A placa BeagleBone Black (BBB) é um hardware de baixo custo \textit{open hardware} e computador expansível
%lançado por uma comunidade de desenvolvedores patrocinada pela \textit{Texas Instruments}. O tamanho da placa
%é pequena do tamanho de um cartão de crédito, onde pode ser usado para uma variedade de projetos acadêmicos ou mesmo aplicações embarcadas de alta complexidade.
%
%A placa possui um processador TI Sitara \texttrademark AM3359 ARM Cortex A8  que funciona a 1 GHz. E uma memória flash on-board de 2 GB atua como "disco rígido" para a placa para armazenar um sistema operacional Linux, ferramentas, códigos, entre outros arquivos.

%As especificações técnicas da placa se encontram na tabela \ref{tabela:BBB}:
%\begin{table}[H]
%	\caption{Características BeagleBone Black }
%\begin{center}
%	\begin{tabular}{ | p{5cm} | p{10cm}|}
%		\hline
%		\textbf{Processador}  & AM3358; \textbf{1GHz} - USB powered or DC powered  \\ \hline
%		\textbf{Memória}  & 512 MB DDR3 SDRAM;\textbf{ 2GB eMMC Flash} \\ \hline
%		\textbf{Alimentação} & USB connection, 5 VDC external jack  \\\hline
%		\textbf{Características da Placa}  & HDMI with audio; USB, 10/100 Ethernet; serial debug via external
%		header  \\ \hline
%		\textbf{Subsistemas Processador}  & 176K ROM; 64K RAM;
%		3D graphics engine; LCD and touchscreen controller; PRU-ICSS;
%		Real Time Clock(RTC); USB ports (2); Ethernet; Controller Area
%		Network; UART (2); McASPs(2); McSPI (2); I2C(2);
%		Analog-to-digital converter; Enhanced Capture Module (3); Pulse
%		width modulation (3); Crypto accelerator;  \\ 
%		\hline
%	\end{tabular}
%\end{center}
%\label{tabela:BBB}

%\end{table}
%
%\subsection{Subsections}
%
%The subsection titles must be in boldface, 12pt, flush left.
%
%\section{Figures and Captions}\label{sec:figs}
%
%
%Figure and table captions should be centered if less than one line
%(Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
%both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
%be Helvetica, 10 point, boldface, with 6 points of space before and after each
%caption.
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure}
%\label{fig:exampleFig1}
%\end{figure}
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2}
%\end{figure}
%
%In tables, try to avoid the use of colored or shaded backgrounds, and avoid
%thick, doubled, or unnecessary framing lines. When reporting empirical data,
%do not use more decimal digits than warranted by their precision and
%reproducibility. Table caption must be placed before the table (see Table 1)
%and the font used must also be Helvetica, 10 point, boldface, with 6 points of
%space before and after each caption.
%
%\begin{table}[ht]
%\centering
%\caption{Variables to be considered on the evaluation of interaction
%  techniques}
%\label{tab:exTable1}
%\includegraphics[width=.7\textwidth]{table.jpg}
%\end{table}
%
%\section{Images}
%
%All images and illustrations should be in black-and-white, or gray tones,
%excepting for the papers that will be electronically available (on CD-ROMs,
%internet, etc.). The image resolution on paper should be about 600 dpi for
%black-and-white images, and 150-300 dpi for grayscale images.  Do not include
%images with excessive resolution, as they may take hours to print, without any
%visible difference in the result. 
%
%\section{References}
%
%Bibliographic references must be unambiguous and uniform.  We recommend giving
%the author names references in brackets, e.g. \cite{knuth:84},
%\cite{boulic:91}, and \cite{smith:99}.
%
%The references must be listed using 12 point font size, with 6 points of space
%before each reference. The first line of each reference should not be
%indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
