\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}	% Inclusão de gráficos


\usepackage{mathtools}
\usepackage[portuguese, ruled, linesnumbered]{algorithm2e}
\usepackage{float}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	tabsize=3
}
     
\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tabela}
     
\sloppy

\title{Algoritimo genético para resoler o problema do caixeiro viajante com o problemas de mochila para cálculo de rotas ótimas para robôs}

\author{Killdary A. Santana\inst{1}}


\address{Departamento de Engengharia Elétrica e da Computação \\ Universidade Federal do Ceará
	(UFC) -- Campus Sobral\\
	Caixa Postal 62010-560 -- Sobral -- CE -- Brazil
	\email{killdary.aguiar@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
	Route planning is becoming a daily task for activities that require the help of robots, such as robotic manipulators on assembly lines and transport robots in industries.
	The great challenge of these robots is to run a better route within their energy limitations. This paper presents the study and development of an application for the planning of beasted routes in the Traveling Salasmen Problem (TSP) combined with the Knapsack Problem (KP) using genetic algorithm (GA). 	
\end{abstract}

\begin{resumo} 
	O planejamento de rotas está se tornando a cada dia uma tarefa corriqueira para 
	atividades que necessitem do auxílio de robôs, como manipuladores robóticos 
	em linhas de montagem e robôs de transporte em indústrias.
	O grande desafio desses robôs é executar uma melhor rota dentro das 
	suas limitações energéticas. Este artigo apresenta o estudo e desenvolvimento 
	de uma aplicação para o planejamento de rotas baseados no Problema do Caixeiro Viajante(PVC) 
	combinado ao Problema da Mochila(PM) por meio de algorítmo genético(AG).
\end{resumo}


\section{Introdução}

Com o avanço da tecnologia os robôs se tornaram mais eficazes na execução de diversas tarefas, podendo executar funções que antes eram consideradas impossíveis para uma máquina, deixando de ser um componente caro e acessível apenas para grandes indústrias e passando a atuar nas mais diversas aplicações que antes eram executadas por humanos, impulsionando assim o desenvolvimento de robôs autônomos.

A finalidade da pesquisa de robôs móveis com autonomia é construir máquinas para realizar tarefas com precisão e capazes de tomar decisões adequadas frente a uma situação inesperada. 

Muitos projetos podem ser observados com as mais diversas finalidades, como exploração de ambientes não estruturados como florestas\cite{article}, exploração de planetas como marte\cite{Nasa:17}, futebol de robôs\cite{ROBOCUP:17}, carros autônomos\cite{Google:19},  aplicações agrícolas\cite{TABILE2011}, entre muitos outros. 

Um dos maiores desafios encontrados em robôs móveis se dá no planejamento de sua trajetória e tem recebido grande atenção por parte dos pesquisadores, tanto na indústria como no meio acadêmico, pois seu desenvolvimento está diretamente relacionado com a maior autonomia dos robôs. A complexidade do problema de planejamento do movimento tem motivado o desenvolvimento dos mais diversos algoritmos. Tal complexidade advém da necessidade de integrar a navegação do robô com o sensoriamento, a eficiência e o planejamento de rotas, como também poupar recurso importantes e preservação de suas partes mecânicas. A habilidade de planejamento de rotas deve estar presente na programação interna dos robôs para que os mesmos possam decidir quando será necessário alterar sua rota de modo a minimizar o impacto em compração ao planejamento inicial.


O problema de roteirização de robôs pode ser modelado através do Problema do Caixeiro Viajante(PCV), porém o PVC não é suficiente para modelar a roteirização de rotas dentro de limitações do robô, como limitação energética ou de peso máximo a ser transportado, sendo assim o mesmo deve ser combinado ao Problema da Mochila(PM) para uma modelagem mais próxima a realidade. Este trabalho tem como objetivo desenvolver um algorítmo genético que forneça a melhor rota para um robô maximizando os ganhos que o mesmo pode realizar dentro de uma limitação energética.

Na próxima seção será descrito o PCV e sua variação síncrona, o PM e a combinação do PCV e PM. Na seção 3 será abordado a fundamentação teórica do problema e da solução a ser implementada. A seção 4 abordará os métodos de implementação e suas metodologias. Na seção 5  será exposto os resultados obtidos oriundos da seção 4, enquanto a conclusão será apresentada na seção 6, e por fim na seção 7 os trabalhos futuros.

\section{Problema do Caixeiro Viajante com o Problema da Mochila} \label{sec:PCVPM}
Para uma melhor representação do problema de roteirização de robôs com restrições será combinado o PCV e o PM. A seguir será apresentado o PCV e sua variação síncrona, usada como base do algorítmo, o PM com sua variação do Problema da Mochila Binária, para adicionar a visitação de uma cidade apenas uma vez, e por fim a combinação dos dois problemas na formulação matemática final.
\subsection{Problema do Caixeiro Viajante} \label{sec:PCV}

O Problema do Caixeiro Viajante (PCV) tem sido muito utilizado no experimento
de diversos métodos de otimização por ser, principalmente, um problema de fácil
descrição e compreensão, mas de grande dificuldade de solução, uma vez que é
NP-difícil(Non-Deterministic Polynomial time). O PCV determina que um vendedor tem N
cidades no qual o mesmo deveria visitar todas as cidades, sem repetir nenhuma, e
voltar para a cidade de partida de modo que o custo da viagem seja mínimo \cite{Singh2013StudyOV}. O
cálculo de rotas mínimas em robôs se assemelha ao PCV, sendo o robô o vendedor, as
cidades os pontos objetivos que o robô deve visitar e as arestas a distância que o robô percorrerá. O PCV é um problema de otimização combinatória, no qual o número de soluções possíveis é representado na equação \ref{fat}.

\begin{equation}\label{fat}
R(n)=(n-1)!
\end{equation}
Onde:
\begin{itemize}
	\item $n$: é o numero de cidades a serem visitadas;
\end{itemize}

\subsubsection{Formulação Matemática Para o PCV}

Seja o grafo $G(N, A)$ onde $N$ representa o conjunto $(|N|=n)$ e $A$ o conjunto de arestas. Seja, uma matriz simétrica com custos ou distâncias mínimas entre os nós da rede considerando ainda que $c_{ij} = +\infty \forall i \in N$. A matriz $X[x_{ij}]$ é composta pelas variáveis de decisão do problema

\begin{equation}
x_{ij} =
\begin{cases} 
1 &\text{, se: o arco } a_{ij} \in \text{rota}\\
0 &\text{, se: o arco } a_{ij} \notin \text{rota}
\end{cases}
\end{equation}

Desta forma, a formulação de Programação Linear Inteira para o problema\cite{doi:10.1287/opre.28.3.694} pode ser escrita como:

\begin{equation}\label{eq:1}
\sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}
Sujeito a:
\begin{equation}\label{eq:2}
\sum_{i=1}^{n}x_{ij} \qquad j=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:3}
\sum_{j=1}^{n}x_{ij} \qquad i=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:4}
X = x_{ij}  \in S
\end{equation}
\begin{equation}\label{eq:5}
x_{ij}=0  \qquad\text{ou} \qquad x_{ij}=1
\end{equation}

Os dois primeiros grupos de restrições (\ref{eq:2}) e (\ref{eq:3}) garantem que exatamente um arco $(i, j)$ tem origem cada nó $i$ da rota e exatamente um arco$(i, j)$ é direcionado para um nó $j$ da rota. A penúltima restrição (\ref{eq:4}) contém um subconjunto $S$ que pode ser qualquer conjunto de restrições que impeça a formação de sub-rotas. Estas restrições são chamadas restrições de quebra de sub-rotas e podem ser, entre outras:

\newcommand{\pctext}[2]{\text{\parbox{#1}{\centering #2}}}
\begin{equation}
S= \biggl\{(x_{ij}) \geq 1 \text{,para todo conjunto próprio não vazio $Q$ de $N$}\biggr\} 
\end{equation}

\begin{equation}
S= \biggl\{(x_{ij}) \leq |R| -1\text{, para todo subconjunto não vazio $R$ de \{ 2,..., n \}} \biggr\} 
\end{equation}


\begin{equation}
S = \biggl\{(x_{ij}):y_i - y_j + nx_{ij} \leq (n-1) \; \text{, para $2\leq i \neq j \leq n$ para alguns números reais $y_i$} \biggr\} 
\end{equation}

O PVC pode ser classificado em simétrico, onde os custos de um caixeiro ir da cidade A para a cidade B e vice-versa são os mesmos, ou assimétrico, onde os custos de movimentação de uma cidade A para uma cidade B podem ser diferentes de ir da cidade B para a cidade A. Para este trabalho será focado no problema \textbf{simétrico}.


\subsubsection{Problema do Caixeiro Viajante Simétrico} \label{sec:PCVS}

O PCVS possui a direção da arestas é irrelevante já que $c_{ij} = c_{ji}$. Uma vez que a direção não tem importância, é possível considerar que o grafo possui apenas um arco, sem direção, entre todos os pares de nós. Deste modo, $x_{j} \in 0,1$ é a variável de decisão onde $j$ percorre todos os arcos $A$ do grafo e $c_{j}$ é o custo de percorrer cada nó. Para encontrar um circuito no grafo, deve selecionar um subconjunto de arcos, no qual todos os nós estejam contidos. Assim, o problema pode ser formulado como:
\begin{equation}\label{fat2}
R(n)=\frac{(n-1)!}{2}
\end{equation}
de modo que o número de resposta é a metade da formulação (\ref{fat}). De modo semelhante ao assimétrico, os sub-circuitos devem ser eliminados. O problema pode então ser formulado como \cite{Tiago:19}:

\begin{equation}\label{eq:12}
min \frac{1}{2}\sum_{j=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}

\begin{equation}\label{eq:13}
 s.t.\sum_{k \in J(j)}^{}x_{k} = 2  \;  \;  \text{,para todo $j=1, ...,m$}
\end{equation}

\begin{equation}\label{eq:14}
\sum_{j \in E(S)}^{}x_{j} \leq |S| - 1  \;  \;  \text{,para todo $S\subset 1, ...,m$}
\end{equation}

\begin{equation}\label{eq:15}
x_j = 0 \text{ ou } x_j = 1  \;  \;  \text{,para todo $j \varepsilon  E$}
\end{equation}
onde $J(j)$ é o conjunto de todos os arcos, não direcionados, ligados ao nó $j$ e $E(S)$ é o subconjunto de todos os arcos que ligam as cidades em qualquer conjunto S não vazio que contenha todas as cidades\cite{Wikipedia:19}.

\subsection{Problema da Mochila (PM)} \label{sec:PM}
O PM é um problema de programação linear inteira, classificado como
NP-hard. O PM consiste de uma mochila com capacidade limitada, dentro dessa mochila deve ser colocado uma lista de itens, cada um com seu peso e valor, de modo que seja agrupado um conjunto de itens na bolsa que sua soma de peso não ultrapassem a capacidade da mochila e a soma dos valores seja a maior  possível\cite{Martello:1990:KPA:98124}. O cálculo da rota de um robô se assemelha ao PM, sendo o robô a mochila, a capacidade da mochila as restrições impostas ao robô, como peso máximo ou energia disponível, e os itens a serem colocados na mochilas são os pontos as serem visitados. 

O PM possui diversas variações, porém um robô que tem sua rota com base no PCV só deverá passar por um ponto uma única vez, sendo assim a o PM binário é a representação dp PM que mais aderente ao problema.

 
\subsubsection{PM binário e sua Formulação Matemática}
A variação PM binária consiste de um conjunto de itens $N$, que é formado por uma lista de $n$ itens $j$ com valor $p_{j}$ e peso $w_{j}$, cada item é de um tipo único, e o valor da capacidade da mochila sendo $C$. O objetivo é selecionar um subset de $N$ no qual a soma dos pesos não exceda $C$ e o valor seja o maior possível\cite{book:946517}. A lista de itens é composta por um vetor $Y[y_{j}]$, no qual

\begin{equation}\label{eq:16}
y_{i} =
\begin{cases} 
1 &\text{, se: o item } y_{i} \in \text{rota}\\
0 &\text{, se: o item } y_{i} \notin \text{rota}
\end{cases}
\end{equation}

Desta forma, a formulação matemática para o problema\cite{book:946517}\cite{Martello:1990:KPA:98124} pode ser descrita como:
r eliminados. O problema pode então ser formulado como \cite{Tiago:19}:

\begin{equation}\label{eq:17}
max \sum_{i=1}^{n}\sum_{i=1}^{n}p_{i}y_{i}
\end{equation}

\begin{equation}\label{eq:18}
s.t.\sum_{i=1}^{n}w_{i}y_{i} \leq  C
\end{equation}


\begin{equation}\label{eq:19}
y_i \in \left \{  0,1 \right \} \qquad i=1,...,m.
\end{equation}


A restrição (\ref{eq:18}) garante que a capacidade da mochila não será ultrapassada. A restrição (\ref{eq:19}) só assume valor $1$ ou $0$. A equação (\ref{eq:17}) garante o maior valor possível na mochila.

\subsection{Problema do Caxeiro Viajante Combinado ao Problema da Mocila (PCVPM)}\label{PCVPM}

Nesta seção, o objetivo deste artigo, a saber, o Problema do Caixeiro Viajante com Problema de Mochila (PCVPM).
Pode-se dizer que esse problema é a junção do PCV Simétrico com o PM binário, de modo que, para 
formulá-lo, foi decidido que devem ser mantidas as principais características de cada um
dos dois problemas componentes:
\begin{enumerate}
	\item Cidades visitadas geram prêmios.
	\item É necessário atender uma quantidade de cidades que proporcione a soma do custo entre cidades não ultrapasse o custo máximo estabelecido.
\end{enumerate}

Obviamente, a primeira caracterísitca é relativa ao PM, enquanto a segunda é uma combinação entre PCV e PM, no qual o peso do item a ser posto na mochila foi substituído pelo
custo de visitação entre as cidades. Observe que, dessa forma, nem todos as cidades precisam ser
visitadas.  O problema consiste em minimizar a soma dos custos de viagem, no qual sua rota é formada
por clientes suficientes para percorrer uma distância menor ou igual a distância preestabelecida,
maximizando os prêmios coletados a cada cliente visitado, de modo que as cidades inclusas na rota sejam visitadas uma única vez.

Mais precisamente, consideremos um grafo $G(N, A)$, onde $N$ representa o conjunto $(|N|=n)$ e $A$ o conjunto de arestas. Seja, uma matriz simétrica com custos ou distâncias mínimas entre os nós da rede considerando ainda que $c_{ij} = +\infty \forall i \in N$. As cidades $x_{i}$ que compõe o conjunto $N$ possuem um prêmio $p_i$. O custo máximo percorrido seja $C$ .A matriz $X[x_{ij}]$ é composta pelas variáveis de decisão do problema:

\begin{equation}
x_{ij} =
	\begin{cases} 
		1 &\text{, se: o arco } x_{ij} \in \text{rota}\\
		0 &\text{, se: o arco } x_{ij} \notin \text{rota}
	\end{cases}
\end{equation}



\begin{equation}
x_{i} =
	\begin{cases} 
		1 &\text{, se: a cidade } x_{i} \in \text{rota}\\
		0 &\text{, se: a cidade } x_{i} \notin \text{rota}
	\end{cases}
\end{equation}

Desta forma, a formulação de Programação Linear Inteira para o problema pode ser escrita como:


\begin{equation}\label{eq:obj_PCVPM}
max. f(x) = \alpha_P\sum_{i=0}^{n}p_{i}x_{i} - \beta_D \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}
\end{equation}

sujeito as restrições:
	
	\begin{equation}\label{eq:PCVPM_rest1}
	\sum_{j=2}^{n}x_{1j} = 1 
	\end{equation}
	
	\begin{equation}\label{eq:PCVPM_rest2}
	\sum_{k=1}^{n-1}x_{in} = 1 
	\end{equation}
	
	\begin{equation}\label{eq:PCVPM_rest3}
	\sum_{i=1}^{n-1}x_{ni} = 0 
	\end{equation}

sobre a quantidade de visitações:


\begin{equation}\label{eq:PCVPM_vis1}
\sum_{i=1}^{n}x_{ij} \qquad j=1,2,\dots,n
\end{equation}
\begin{equation}\label{eq:PCVPM_vis2}
\sum_{j=1}^{n}x_{ij} \qquad i=1,2,\dots,n
\end{equation}

sobre a distância máxima a ser percorrida:

\begin{equation}\label{eq:PCVPM_Max_dist}
 \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij} \leq C_T
\end{equation}

sobre a aliminação de subrotas:

\begin{equation}\label{eq:PCVPM_sub1}
 1 \leq u_i \leq n \qquad\forall i \in T
\end{equation}


\begin{equation}\label{eq:PCVPM_sub2}
i_i - u_j + 1 \leq (1 + -x_{ij})n \qquad  2\leq i \neq j \leq n
\end{equation}


onde $n$ é o tamanho do conjunto de cidades a serem visitadas, $T$ é conjuntos de cidades que comõe uma rota viável, $c_{ij}$ é o custode movimentação entre uma cidade e outra, $p_i$ é o prêmio da $i$-ésima cidade, $\alpha_P$ e $\beta_D$ são os pesos na fução objetivo relacionados a maximização da premiação e minimização do custo

Neste problema as equações (\ref{eq:PCVPM_rest1}) e (\ref{eq:PCVPM_rest2}) são restrições sobre o ponto inicial e final que devem ser inclusos na rota, a restição (\ref{eq:PCVPM_rest3}) impõe que nenhum ponto apos chegar ao ponto final seja visitado, (\ref{eq:PCVPM_vis1}) e (\ref{eq:PCVPM_vis2}) restringe que cada ponto seja visitado apenas uma única vez, a equação (\ref{eq:PCVPM_Max_dist}) limita a distância máxoma percorrida a $C_{T}$, subrotas são impedidas de ser geradas pelas equações (\ref{eq:PCVPM_sub1}) e (\ref{eq:PCVPM_sub2}).

O resultaddesta otimização será um conjunto de vertices ordenados a serem visitados pelo agente.

\section{Algoritmo Genético}
Os Algoritmos Genéticos (AGs) são técnicas de otimização inspirados no
princípio da sobrevivência e reprodução dos indivíduos mais aptos, proposto por
Charles Darwin\cite{book:54924}\cite{book:1176457}.

O Algoritmo Genético é baseado em um conjunto de soluções candidatas que representam uma solução para o problema de otimização que se deseja resolver. Uma solução é um candidato em potencial para otimizar o problema. A forma de representação desempenha um papel importante, uma vez que determina a escolha dos operadores genéticos.

As representações geralmente são listas de valores e por muitas vezes são mais baseadas em conjuntos de
símbolos. Caso o conjunto de símbolos sejam contínuos, eles serão chamados de vetores, caso eles consistem em bits, eles
serão chamadas de strings de bits. Em caso de problemas combinatórios, as soluções geralmente consistem em
símbolos que aparecem em uma lista. A representação pode ser aplicado ao planejamento de rotas como um percurso realizado pelo caixeiro viajante. Os operadores genéticos produzem novas soluções a partir da representação escolhida e permite a aproximação da solução. A codificação da solução, no qual pode ser aplicado o processo evolutivo, é chamada de genótipo ou cromossomo.

O algoritmo \ref{algoritmo1} mostra o pseudocódigo do AG básico. No início, um conjunto de soluções, chamado de população, é inicializada. Esta inicialização é utilizada para gerar aleatoriamente o conjunto de soluções\cite{book:1613056}. 


\begin{algorithm}\label{algoritmo1}
	iniciar população;
	\Repeat{}{
		\Repeat{}{
			cruzamento\;
			mutação\;
			avaliação\;
			seleção\;
		}população completa\;
		atualização
		teste de Parada
	}finalização
	\caption{Algorítimo Genético}
\end{algorithm}

O principal ciclo geracional do Algoritmo Genético gera uma nova prole de  soluções candidatas, através do cruzamento e  da mutação, até a população estar completa.

\subsection{Implementação}
A ferramenta utilizada para realizar a implementação foi a linguagem $Python$. O Python ocupa o primeiro lugar no \textit{ranking spectrun da IEEE}\cite{IEEE} em linguagens de cálculos científicos, já  possui funções nativas  de cálculos semelhantes ao Matlab, porém as mesmas ainda se demonstraram insuficientes para adaptar com precisão de tempo o algoritmo escolhido, para resolver este problema foi utilizado o pacote Numpy, que é pacote cientifico da linguagem \cite{Numpy}.

Para atender às necessidades de um sistema baseado em AG's, tem-se como principais requisitos do sistema, a passagem de parâmetros: número de gerações, tamanho da população, tamanho de geração sem alteração no melhor indivíduo, peso máximoa ser percorrido, arquivo com pontos a serm visitados, arquivo com premiacoes de cada cidade e o ponto inicial. O programa foi criado projetado para ser executado através da linha de comando, para uma flexidade maior na mudanças dos parâmetros, aceitando a sintaxe:

\begin{algorithm}

PCVPM\_GA.py  [size\_generation] [size\_population] [num\_generation\_limit] [max\_coust] [towns\_list] [weight\_list] [begin\_deposit]
	\caption{Execução em linha de comando do algorítmo}
\end{algorithm}

A linguagem Python também foi escolhida pela possibilidade de ser embarcada em um computador de placa única ARM (\textit{single-board computer} - SBC)  é um computador completo construído em uma única placa de circuito , com microprocessador ARM, memória, entrada/saída (E/S) e outros recursos necessários para um computador funcional\cite{allaboutcircuits:Robin}.




\subsection{ARM SBCs}
Um computador de placa única ARM (\textit{single-board computer} - SBC) é um computador completo construído em uma única placa de circuito , com microprocessador ARM, memória, entrada/saída (E/S) e outros recursos necessários para um computador funcional. Os computadores de placa única foram feitos como sistemas de demonstração ou desenvolvimento, para sistemas educacionais ou para uso como controladores de computador incorporados. Muitos tipos de computadores domésticos ou computadores portáteis integram todas as suas funções em uma única placa de circuito impresso. Estes dispositivos ganharam grande visibilidade em 2012 quando foi lançado pela \textit{Raspberry Pi Foundation} o SBC \textit{Raspberry Pi}, o intuito da fundação era disseminar o ensino de Ciência da Computação nas escolas, porém a placa demonstrou ser uma ótima alternativa para desenvolvimento dos mais diversos projetos na industria e na área acadêmica. Desde então diversos SBC's foram lançados para as mais diversas funcionalidades\cite{allaboutcircuits:Robin}.

A tabela \ref{tabela:BBB} faz uma comparação das especificações das placas utilizadas neste estudo:

\begin{table}[H]
	\caption{Características BeagleBone Black }
	\begin{center}
		\begin{tabular}{ | p{2.2cm} | p{2.5cm}| p{2.5cm}| p{2.5cm}| p{2.5cm}|}
			\hline
			 &\textbf{BeagleBone Black}&\textbf{Raspberry Pi 3}&\textbf{Raspberry Pi A+}&\textbf{Orange Pi One}\\ \hline
			\textbf{Processador}  &ARM Cortex A8 &ARM Cortex-A53 64-bit&ARM 1176JZF-S&ARM H3 Quad-core\\ \hline
			\textbf{Clock}  &1 GHz&1 GHz&700 MHz&1 GHz\\ \hline
			\textbf{Ram}  &	512 MB&1 GB &256 Mb&512 MB\\ \hline
			\textbf{Storage}  &2 GB on-board eMMC, MicroSD&MicroSD&MicroSD&MicroSD\\ \hline
			\textbf{Alimentação}  &210-460 mA @ 5V&	800 mA @ 5V&200 mA  @ 5V&300 mA  @ 5V\\ \hline
			\textbf{Quantidade de GPIO}  &92&40&40&40\\ \hline
			\textbf{Preço}  &US\$45.00&US\$35.00&US\$20.00&US\$10.00\\ 
			\hline
		\end{tabular}
	\end{center}
	\label{tabela:BBB}
\end{table}\cite{raspberry}\cite{orangepi:Orange}\cite{orangepi:Eric}\cite{adafruit:Tony}

Os dados acima foram levantados na data 2017-12-22.

\section{Método de Implementação}

A  metodologia de desenvolvimento segue as seguintes etapas:
\begin{itemize}
	\item Definição do ambiente de testes;
	\item Adaptação Algorítimo Genético para Python 3.6:
		\subitem Multiplataforma;
		\subitem Similaridade com Matlab;
		\subitem Vasta utilização em \textit{data science} segundo a IEEE\cite{IEEE};
	\item Portabilização para as plataformas;
	\item Critérios de execução:
		\subitem tempo limite;
		\subitem consumo de RAM;
		\subitem consumo de CPU;
	\item Ambiente físico de execução de testes;
	\item Interpretação dos testes.			
\end{itemize}

Para realizar a comparação de desempenho proposto por esta pesquisa é fundamental que todas as placas sejam submetidas ao mesmo ambiente de teste, respeitando as especificações técnicas de cada plataforma. O ambiente de testes foi aplicado sobre um sistema operacional Linux, no qual para cada plataforma foi utilizado o sistema disponibilizado pelo seu respectivo fabricante, a lista abaixo exibe cada sistema utilizado:

\begin{itemize}
	\item BeagleBobe Black: Debian 9.2 IoT\cite{BeagleBoard};
	\item Raspberry Pi 3: Raspbian Stretch with Desktop\cite{raspberry};
	\item Raspberry Pi A+: Raspbian Stretch with Desktop\cite{raspberry};
	\item Orange Pi One: Lubuntu \cite{orangepi:Orange}.
\end{itemize}\label{lista os}

A base do desenvolvimento deste artigo foi o algoritmo proposto por \cite{Singh2013StudyOV},neste estudo é realizado a implementação de um algoritmo genético, no qual os resultados se demonstraram bastantes promissores. No estudo é utilizado um algoritmo em Matlab. Para o desenvolvimento embarcado a memória e o processamento são recursos preciosos, porém o Matlab exige, em seus requisitos mínimos, 2 Gb de RAM e 2,2 Gb de armazenamento, sendo que em plataformas embarcadas a memória RAM e a memória de armazenamento possuem capacidades inferiores ao exigido, desta forma não é possível utilizar o algoritmo original para os testes nas plataformas embarcadas. Para contornar este problema foi realizado uma adaptação do algorítimo para uma linguagem presentes nos sistemas citados, a linguagem escolhida foi o Python na sua versão 3.6 \cite{Python}.

O Python ocupa o primeiro lugar no \textit{ranking spectrun da IEEE}\cite{IEEE} em linguagens de cálculos científicos, já  possui funções nativas  de cálculos semelhantes ao Matlab, porém as mesmas ainda se demonstraram insuficientes para adaptar com precisão de tempo o algoritmo escolhido, para resolver este problema foi utilizado o pacote Numpy, que é pacote cientifico da linguagem \cite{Numpy}.


A análise das plataformas foi feita considerando os seguintes aspectos:
\begin{itemize}
	\item tempo de execução: tempo utilizado pela placa para a execução do algoritimo;
	\item consumo de RAM: consumo de memória RAM realizado pelo GA;
	\item consumo de processamento: processamento consumido pelo GA.
\end{itemize}

A medida do tempo de execução foi realizada utilizando o módulo nativo do Python \textit{timeit},este módulo possui uma função chamada \textit{repeat} no qual  a definição encontradoa no \textit{help()} da linguagem define:
\begin{quote}
	Esta é uma função conveniente que chama o \textit{timeit()} repetidamente, retornando uma lista de resultados. O primeiro argumento \textit{repeat}	especifica quantas vezes deverá ser executado chamado o \textit{timeit()}, o padrão é igual à 3; 	o segundo argumento especifica o \textit{number} que define quantos testes são feitos em cada repetição,o valor padrão é igual 1000000.
\end{quote}
  Para a medida de uso de memória e de CPU foi utilizando o comando nativo do Linux \textit{top} , este comando oferece um conjunto de estatísticas sobre o estado geral, assim como dos processos com maior atividade no sistema. Essa lista é apresentada e atualizada de 2 em 2 segundos. Depois de captar os dados de cada plataforma é realizada a comparação entre elas.
  
O ambiente de testes para cada plataforma foi realizada de maneira que simulasse os mesmos aspectos para todas as plataformas. O ambiente de testes possui as características:
\begin{itemize}
	\item temperatura de 23 graus Celsius controlada por um ar-condicionado;
	\item versão do Python 3.6;
	\item versao do Numpy versão 1.13.3;
	\item parâmetros do algoritmo genético:
		\subitem tempo de execução: 60 minutos;
		\subitem população: 50;
		\subitem gerações: 100;
		\subitem a matriz de distâncias entre os pontos sempre o mesmo;
	\item parâmetros de execução:
		\subitem número de repetições: 10;
		\subitem número de execuções por repetição: 10;
	
\end{itemize}

Por fim a interpretação dos testes.

\section{Resultados}
Os experimentos são conduzidos para avaliar o desempenho de cada plataforma. Os testes em todas as plataformas foram executados sempre no mesmo ambiente sobe as mesmas condições físicas e de software. Para cada teste foi definido um tempo máximo de execução de 60 minutos, este tempo foi baseado no tempo médio de execução do algoritmo em uma plataforma não embarcada, notebook com processador core i7 de 1.8 GHz e 8 Gigabytes de memória RAM, definindo o mesmo número de repetições e execuções, 10 repetições e 10 execuções, o tempo de execução no notebook foi de 30 minutos, já nos testes das plataformas embarcadas este tempo foi dobrado para compensar sua baixa memória e seu baixo poder de processamento e executando o mesmo número de repetições e de execuções.

Ao iniciar os testes todas as plataformas concluiram a análise dentro do tem máximo definifo, com excexão do placa Raspberry Pi A+, a mesma não conseguiu executar o teste em tempo hábil, desta forma os testes foram abostrados e seus dados nos gráficos seguintes irão ser exibidos com valores zerados.

O foco do experimento não baseia-se apenas no tempo de execução do algoritmo mas também no uso de CPU e memória RAM.

\subsection{Tempo de Execução}

O tempo de execução de cada plataforma é definido pela média resultados retornados pela função \textit{timeit.repeat()}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=.7\textwidth]{Time.png}
	\caption{Tempo médio de execução}
	\label{fig:Time}
\end{figure}

\subsection{Memória RAM}

O consumo de RAM de cada plataforma é definido pela média resultados captados apartir da função do Linux \textit{top}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=.7\textwidth]{RAM.png}
	\caption{Consumo médio de memória RAM}
	\label{fig:RAM}
\end{figure}

\subsection{CPU}

O uso de CPU de cada plataforma é definido pela média de resultados captados apartir da função do Linux \textit{top}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=.7\textwidth]{CPU.png}
	\caption{Uso médio de memória CPU}
	\label{fig:CPU}
\end{figure}

\subsection{Tabela de Comparação de desempenho}

\begin{table}[H]
	\caption{Características BeagleBone Black }
	\begin{center}
		\begin{tabular}{ | p{2.2cm} | p{2.5cm}| p{2.5cm}| p{2.5cm}| p{2.5cm}|}
			\hline
			&\textbf{BeagleBone Black}&\textbf{Raspberry Pi 3}&\textbf{Raspberry Pi A+}&\textbf{Orange Pi One}\\ \hline
			\textbf{Tempo Execução (seg.)}  &64 &23.51&0&31\\ \hline
			\textbf{RAM (Mb)}  &17,48&16&0&17,48\\ \hline
			\textbf{CPU (MHz)}  &980&1000&0&1000\\ \hline
			
		\end{tabular}
	\end{center}
	\label{tabela:Resultados}
\end{table}

\section{Conclusão}

Os testes demonstraram que o Raspberry Pi 3 possui uma melhor performance na execução do AG proposto, seguido do Orange Pi One e BeagleBone Black. O Raspberry Pi A+ demonstrou não ser uma boa opção para a execução do algorítimo.

Apesar do Raspberry Pi 3 possuir um melhor performance o Orange Pi One demonstrou ser uma ótima escolha considerando que seu desempenho aproximou-se do Raspberry Pi 3 e seu custo ser menor, ver tabela \ref{tabela:BBB}, sendo assim a melhor plataforma pode ser definida tendo em consideração seu uso final.


\section{Trabalhos Futuros}
Temdo em comparação dos resultados e de performance, os seguintes resultados devem persuadir trabalhos futuros. A comparação de performance e de custo não são as únicas métricas que devem ser levadas em consideração na escolha da platforma, a eficiência enérgética deve ser levada em conta, no qual poderá ser realizada em pesquisas futuras. 

%



%\subsubsection{ BeagleBone Black (BBB)}
%A placa BeagleBone Black (BBB) é um hardware de baixo custo \textit{open hardware} e computador expansível
%lançado por uma comunidade de desenvolvedores patrocinada pela \textit{Texas Instruments}. O tamanho da placa
%é pequena do tamanho de um cartão de crédito, onde pode ser usado para uma variedade de projetos acadêmicos ou mesmo aplicações embarcadas de alta complexidade.
%
%A placa possui um processador TI Sitara \texttrademark AM3359 ARM Cortex A8  que funciona a 1 GHz. E uma memória flash on-board de 2 GB atua como "disco rígido" para a placa para armazenar um sistema operacional Linux, ferramentas, códigos, entre outros arquivos.

%As especificações técnicas da placa se encontram na tabela \ref{tabela:BBB}:
%\begin{table}[H]
%	\caption{Características BeagleBone Black }
%\begin{center}
%	\begin{tabular}{ | p{5cm} | p{10cm}|}
%		\hline
%		\textbf{Processador}  & AM3358; \textbf{1GHz} - USB powered or DC powered  \\ \hline
%		\textbf{Memória}  & 512 MB DDR3 SDRAM;\textbf{ 2GB eMMC Flash} \\ \hline
%		\textbf{Alimentação} & USB connection, 5 VDC external jack  \\\hline
%		\textbf{Características da Placa}  & HDMI with audio; USB, 10/100 Ethernet; serial debug via external
%		header  \\ \hline
%		\textbf{Subsistemas Processador}  & 176K ROM; 64K RAM;
%		3D graphics engine; LCD and touchscreen controller; PRU-ICSS;
%		Real Time Clock(RTC); USB ports (2); Ethernet; Controller Area
%		Network; UART (2); McASPs(2); McSPI (2); I2C(2);
%		Analog-to-digital converter; Enhanced Capture Module (3); Pulse
%		width modulation (3); Crypto accelerator;  \\ 
%		\hline
%	\end{tabular}
%\end{center}
%\label{tabela:BBB}

%\end{table}
%
%\subsection{Subsections}
%
%The subsection titles must be in boldface, 12pt, flush left.
%
%\section{Figures and Captions}\label{sec:figs}
%
%
%Figure and table captions should be centered if less than one line
%(Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
%both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
%be Helvetica, 10 point, boldface, with 6 points of space before and after each
%caption.
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure}
%\label{fig:exampleFig1}
%\end{figure}
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2}
%\end{figure}
%
%In tables, try to avoid the use of colored or shaded backgrounds, and avoid
%thick, doubled, or unnecessary framing lines. When reporting empirical data,
%do not use more decimal digits than warranted by their precision and
%reproducibility. Table caption must be placed before the table (see Table 1)
%and the font used must also be Helvetica, 10 point, boldface, with 6 points of
%space before and after each caption.
%
%\begin{table}[ht]
%\centering
%\caption{Variables to be considered on the evaluation of interaction
%  techniques}
%\label{tab:exTable1}
%\includegraphics[width=.7\textwidth]{table.jpg}
%\end{table}
%
%\section{Images}
%
%All images and illustrations should be in black-and-white, or gray tones,
%excepting for the papers that will be electronically available (on CD-ROMs,
%internet, etc.). The image resolution on paper should be about 600 dpi for
%black-and-white images, and 150-300 dpi for grayscale images.  Do not include
%images with excessive resolution, as they may take hours to print, without any
%visible difference in the result. 
%
%\section{References}
%
%Bibliographic references must be unambiguous and uniform.  We recommend giving
%the author names references in brackets, e.g. \cite{knuth:84},
%\cite{boulic:91}, and \cite{smith:99}.
%
%The references must be listed using 12 point font size, with 6 points of space
%before each reference. The first line of each reference should not be
%indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
